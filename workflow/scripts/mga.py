# SPDX-FileCopyrightText: 2022 Koen van Greevenbroek & Aleksander Grochowicz
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""Perform MGA.

Specifically, optimise a PyPSA network in the principle directions
with a near-optimality constraint. This leads to a first approximation
of the near-optimal feasible space.

"""

import copy
import logging
import multiprocessing
import os
import time
from collections import OrderedDict
from multiprocessing import Pool
from pathlib import Path

import numpy as np
import pandas as pd
import pypsa
from pypsa.components import component_attrs, components
from _helpers import configure_logging
from utilities import get_basis_values, solve_network_in_direction, override_component_attrs


def mga(
    n: pypsa.Network,
    basis: OrderedDict,
    opt_point: pd.DataFrame,
    obj_bound: float,
    debug_dir: str,
    num_parallel_solvers: int,
) -> pd.DataFrame:
    """Perform MGA in given basis with maximum objective `obj_bound`.

    Obtain the extremal points in the basis directions, which come from a
    projection of the entire feasible space of `n` onto the lower-dimensional
    space spanned by a selection of decision variables (or sums of decision
    variables). Specifically, the projection is the span of the vectors given
    by the `basis` argument. The elements of this collection are assumed to
    be linear expressions generated by `pypsa.linopt.linexpr`.

    The near-optimal feasible space is defined as the feasible space
    of `n` with the additional constraint 'c.x <= (1 + `eps`) * OPT',
    where c is the objective function and OPT the optimal value, given here
    by `obj_bound`.

    The return value is a collection of points given in the basis
    specified by `basis`. The convex hull of these points is a first
    approximation of the near-optimal feasible space of `n`.

    Parameters
    ----------
    n : pypsa.Network
    basis : OrderedDict
        A basis on which to project the feasible space of `n`. The
        keys being the decision variables with values given in the
        format produced by `pypsa.linopt.linexpr`.
    opt_point : pd.DataFrame
        Coordinates of the cost-optimal solution in the projection defined by
        `basis`.
    obj_bound : float
        Upper bound for costs in the near-optimality constraint.
    debug_dir : str
        Directory where the debug files (networks) should be saved.
    num_parallel_solvers : int
        The number of parallel processes to use.

    Returns
    -------
    pd.DataFrame
        A collection of points in the basis of `basis`, whose
        convex hull is a first approximation of the near-optimal feasible
        (MGA) space of the given model.
    """
    # Make a copy of the input network so we do not modify the arguments.
    m = copy.deepcopy(n)

    # Prepare the near-optimal feasible space, represented by a
    # collection of points. Initially, it just contains the optimal
    # solution. This point has index '-1' for our purposes.
    points = opt_point
    points.index = [-1]

    # Make sure the directory we put the debug networks in exists.
    Path(debug_dir).mkdir(exist_ok=True, parents=True)

    # Generate the direction to optimise in.
    mga_directions = list(np.eye(len(basis))) + list(-np.eye(len(basis)))

    # Make some easy-to-read descriptions for the directions.
    comps = list(basis.keys())
    descriptions = ["min_" + c for c in comps] + ["max_" + c for c in comps]

    # Start a pool of worker processes:
    logging.info("Starting MGA optimisations.")
    with Pool(num_parallel_solvers) as pool:
        args = [
            (m, d, basis, obj_bound, debug_dir, desc)
            for d, desc in zip(mga_directions, descriptions)
        ]
        results = pool.starmap_async(mga_worker, args).get()

    # Collect all the resulting points in one dataframe. It is indexed
    # from -1, with the '-1'-th point being the optimum solution.
    result_dfs = [pd.DataFrame(r, index=[0]) for r in results if r is not None]
    points = pd.concat([opt_point] + result_dfs, ignore_index=True)
    points.index = range(-1, len(result_dfs))
    return points


def mga_worker(
    n: pypsa.Network,
    direction: np.array,
    basis: OrderedDict,
    obj_bound: float,
    debug_dir: str,
    description: str,
):
    """Run MGA in given basis with maximum objective `obj_bound` in parallel."""
    # Log the start of this iteration. Note that we cannot really use
    # the `logging` package here since it is not process-safe, so we
    # just use a print statement. At least it lets the user know
    # what is going on.
    worker_name = multiprocessing.current_process().name
    print(f"{worker_name}: Solving for {description}...")

    # Solve the network.
    t = time.time()
    status, _ = solve_network_in_direction(n, direction, basis, obj_bound)
    solve_time = round(time.time() - t)
    print(f"{worker_name}: Finished solving for {description} in {solve_time} seconds")

    # Export the network for debug purposes.
    n.export_to_netcdf(os.path.join(debug_dir, f"{description}.nc"))

    # If the solve was successful, return the results. Otherwise,
    # return nothing. Unsuccessful solves can happen sporadically due
    # to, for example, numerical issues.
    if status == "ok":
        return get_basis_values(n, basis)
    else:
        print("Optimisation unsuccessful: ignoring results.")
        return None


if __name__ == "__main__":
    # Set up logging so that everything is written to the right log file.
    configure_logging(snakemake)

    # Disable logging from pypsa; it mostly just distracts for this script.
    pypsa_logger = logging.getLogger("pypsa")
    pypsa_logger.setLevel(logging.WARNING)

    # Load the network and solving options.
    overrides = override_component_attrs(snakemake.input.overrides)
    n = pypsa.Network(snakemake.input.network, override_component_attrs=overrides)


    # Attach solving configuration to the network.
    n.config = snakemake.config["pypsa-eur"]

    # Load other inputs (the optimal point, the near-optimality
    # constraint) to the MGA computation.
    opt_point = pd.read_csv(snakemake.input.optimum, index_col=0)
    with open(snakemake.input.obj_bound, "r") as f:
        obj_bound = float(f.read())

    # Perform MGA to get a number of points on the boundary of the
    # projected near-optimal feasible space.
    mga_space = mga(
        n,
        basis=snakemake.config["projection"],
        opt_point=opt_point,
        obj_bound=obj_bound,
        debug_dir=snakemake.log.debug,
        num_parallel_solvers=snakemake.config["near_opt_approx"].get(
            "num_parallel_solvers", 1
        ),
    )

    # Write to result to the given output files.
    mga_space.to_csv(snakemake.output.mga_space)
